{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>pwlreg</code> - Piecewise Linear Regression","text":"<p><code>pwlreg</code> is a scikit-learn-compatible implementation of Piecewise Linear Regression.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#with-pip","title":"With pip","text":"<pre><code>pip install pwlreg\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>See the quickstart guide to get started with <code>pwlreg</code>.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\nimport pwlreg as pw\n\n\nx = np.array([1., 2., 3., 4., 5., 6., 7., 8., 9., 10.])\ny = np.array([1., 1.5, 0.5, 1., 1.25, 2.75, 4, 5.25, 6., 8.5])\n\nm = pw.AutoPiecewiseRegression(n_segments=2, degree=[0, 1])\nm.fit(x, y)\n\nxx = np.linspace(1, 10, 100)\nplt.plot(x, y, \"o\")\nplt.plot(xx, m.predict(xx), \"-\")\nplt.show()\n</code></pre> <p></p>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<pre><code>import numpy as np\nimport pwlreg as pw\nimport matplotlib.pyplot as plt\n</code></pre> <pre><code>x = np.array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0])\ny = np.array([1.0, 1.5, 0.5, 1.0, 1.25, 2.75, 4, 5.25, 6.0, 8.5])\nxx = np.linspace(1, 10, 100)\n</code></pre> <pre><code>m1 = pw.PiecewiseLinearRegression()\nm1.fit(x, y)\n</code></pre> <pre>PiecewiseLinearRegression(breakpoints=array([ 1., 10.]), degree=[1])</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org. <p>PiecewiseLinearRegression<pre>PiecewiseLinearRegression(breakpoints=array([ 1., 10.]), degree=[1])</pre> <p> </p> <pre><code>plt.plot(x, y, \"o\")\nplt.plot(xx, m1.predict(xx), \"-\")\nplt.ylim(-1, 10)\nplt.show()\n</code></pre> <p>You can view the breakpoints and the model coefficients once the model has been fit.</p> <pre><code>print(\"Breakpoints:\", m1.breakpoints)\nprint(\"Coefs:\", m1.coef_)\n</code></pre> <pre>\n<code>Breakpoints: [ 1. 10.]\nCoefs: [-1.26666667  0.80757576]\n</code>\n</pre> <p>And you can calculate model metrics however you are accustomed to:</p> <pre><code>from sklearn.metrics import mean_squared_error\n\nrmse = mean_squared_error(y, m1.predict(x), squared=False)\nprint(\"RMSE:\", rmse)\nprint(\"CVRMSE: {:.2%}\".format(rmse / y.mean()))\n</code></pre> <pre>\n<code>RMSE: 1.0405054133215816\nCVRMSE: 32.77%\n</code>\n</pre> <p>To specify a breakpoint, the <code>breakpoints</code> argument must include the minimum and maximum values of the input data. Notice that when we passed <code>breakpoints=None</code> above, the estimator automatically set the breakpoints to 1 and 10. If you pass the breakpoints manually, you will need to explicitly provide these. For example, suppose we wanted to put a breakpoint at <code>x = 4</code>.</p> <pre><code>m2 = pw.PiecewiseLinearRegression(breakpoints=[1.0, 4.0, 10.0])\nm2.fit(x, y)\n</code></pre> <pre>PiecewiseLinearRegression(breakpoints=[1.0, 4.0, 10.0], degree=[1, 1])</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org. <p>PiecewiseLinearRegression<pre>PiecewiseLinearRegression(breakpoints=[1.0, 4.0, 10.0], degree=[1, 1])</pre> <p> </p> <pre><code>plt.plot(x, y, \"o\")\nplt.plot(xx, m2.predict(xx), \"-\")\nplt.ylim(-1, 10)\nplt.show()\n</code></pre> <p>Now there are four model coefficients. In order, these are: the intercept and slope of the first (leftmost) line segment, and the intercept and slope of the last line segment.</p> <pre><code>m2.coef_\n</code></pre> <pre>\n<code>array([ 1.55319149, -0.28191489, -4.4893617 ,  1.2287234 ])</code>\n</pre> <p>The model fits significantly better than the single line did, as we can see both visually and with error metrics:</p> <pre><code>rmse = mean_squared_error(y, m2.predict(x), squared=False)\nprint(\"RMSE:\", rmse)\nprint(\"CVRMSE: {:.2%}\".format(rmse / y.mean()))\n</code></pre> <pre>\n<code>RMSE: 0.4154592434628495\nCVRMSE: 13.09%\n</code>\n</pre> <p>By default, each segment is a 1-degree polynomial (i.e. a line). In some change-point models, we want to restrict one or more segments to be constant. Do that by passing the <code>degree</code> argument as a list, with one degree value for each line segment.</p> <pre><code>m3 = pw.PiecewiseLinearRegression(breakpoints=[1.0, 3.5, 10.0], degree=[0, 1])\nm3.fit(x, y)\n</code></pre> <pre>PiecewiseLinearRegression(breakpoints=[1.0, 3.5, 10.0], degree=[0, 1])</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org. <p>PiecewiseLinearRegression<pre>PiecewiseLinearRegression(breakpoints=[1.0, 3.5, 10.0], degree=[0, 1])</pre> <p> </p> <pre><code>plt.plot(x, y, \"o\")\nplt.plot(xx, m3.predict(xx), \"-\")\nplt.ylim(-1, 10)\nplt.show()\n</code></pre> <p>Now there are only three model coefficients. Because the first segment is a flat line, it only has one coefficient, the constant term. The second and third coefficients are the intercept and slope of the last segment as before.</p> <pre><code>m3.coef_\n</code></pre> <pre>\n<code>array([ 0.56026059, -3.17508143,  1.06724058])</code>\n</pre> <p>This model fits better than the single line did, but not as well as the one with two degree-one segments. Maybe we picked the wrong breakpoint?</p> <pre><code>rmse = mean_squared_error(y, m3.predict(x), squared=False)\nprint(\"RMSE:\", rmse)\nprint(\"CVRMSE: {:.2%}\".format(rmse / y.mean()))\n</code></pre> <pre>\n<code>RMSE: 0.5863738922856399\nCVRMSE: 18.47%\n</code>\n</pre>"},{"location":"quickstart/#pwlreg-quick-start","title":"<code>pwlreg</code> Quick Start","text":""},{"location":"quickstart/#how-to-use-pwlreg","title":"How to Use <code>pwlreg</code>","text":"<p><code>pwlreg</code> performs p iece w ise l inear reg ression. It is general enough to suit any use case, but it was developed specifically to estimate change-point building energy models. ASHRAE calls this family of models \u201cinverse models\u201d; they are really just regression models with two or three piecewise components.</p> <p>The <code>pwlreg</code> library was written to be fully compatible with the scikit-learn API. It exposes two estimators: <code>PiecewiseLinearRegression</code> and <code>AutoPiecewiseRegression</code>. They differ in how they handle breakpoints (or change points): if you want to specify the breakpoints yourself, use <code>PiecewiseLinearRegression</code>. If you want to find the optimal breakpoints automatically, use <code>AutoPiecewiseRegression</code>.</p> <pre><code>m4 = pw.AutoPiecewiseRegression(n_segments=2, degree=[0, 1])\nm4.fit(x, y)\n</code></pre> <pre>AutoPiecewiseRegression(degree=[0, 1], n_segments=2)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org. <p>AutoPiecewiseRegression<pre>AutoPiecewiseRegression(degree=[0, 1], n_segments=2)</pre> <p> </p> <pre><code>plt.plot(x, y, \"o\")\nplt.plot(xx, m4.predict(xx), \"-\")\nplt.ylim(-1, 10)\nplt.show()\n</code></pre> <p>This looks like a better location for the breakpoint. We can once again inspect the breakpoint, the model coefficients, and the error metrics:</p> <pre><code>print(\"Breakpoints:\", m4.breakpoints_)\nprint(\"Coefficients:\", m4.coef_)\n\nrmse = mean_squared_error(y, m4.predict(x), squared=False)\nprint(\"RMSE:\", rmse)\nprint(\"CVRMSE: {:.2%}\".format(rmse / y.mean()))\n</code></pre> <pre>\n<code>Breakpoints: [ 1.          4.81481479 10.        ]\nCoefficients: [ 0.99999999 -5.49999995  1.34999999]\nRMSE: 0.34641016151377557\nCVRMSE: 10.91%\n</code>\n</pre> <p>This is our best-fitting model yet. The optimal breakpoint is around 4.8. We are not limited to straight lines if we think a quadratic might give us a better fit:</p> <pre><code>m5 = pw.AutoPiecewiseRegression(2, degree=[0, 2])\nm5.fit(x, y)\n\nplt.plot(x, y, \"o\")\nplt.plot(xx, m5.predict(xx), \"-\")\nplt.ylim(-1, 10)\nplt.show()\n</code></pre> <pre><code>rmse = mean_squared_error(y, m5.predict(x), squared=False)\nprint(\"RMSE:\", rmse)\nprint(\"CVRMSE: {:.2%}\".format(rmse / y.mean()))\n</code></pre> <pre>\n<code>RMSE: 0.3305838990302607\nCVRMSE: 10.41%\n</code>\n</pre> <pre><code>rng = np.random.default_rng(1234)\ncp1, cp2 = 52, 73\n\nx = np.concatenate(\n    (\n        rng.uniform(0, cp1, 300),\n        rng.uniform(cp1, cp2, 400),\n        rng.uniform(cp2, 100, 300),\n    )\n)\n\ny = np.piecewise(\n    x,\n    [x &amp;lt; cp1, (cp1 &amp;lt;= x) &amp;amp; (x &amp;lt; cp2), x &amp;gt;= cp2],\n    [\n        lambda a: 10 + 0.25 * (cp1 - a),\n        10,\n        lambda a: 10 + 0.5 * (a - cp2),\n    ],\n)\n\nsigma = np.piecewise(\n    x,\n    [x &amp;lt; cp1, (cp1 &amp;lt;= x) &amp;amp; (x &amp;lt; cp2), x &amp;gt;= cp2],\n    [\n        lambda a: 1 + 0.10 * (cp1 - a),\n        1,\n        lambda a: 1 + 0.15 * (a - cp2),\n    ],\n)\n\ny += rng.normal(0, sigma, 1000)\ny = np.abs(y)\n</code></pre> <pre><code>plt.plot(x, y, \".\")\nplt.show()\n</code></pre> <pre><code>from sklearn.model_selection import GridSearchCV\n\nm = pw.AutoPiecewiseRegression(n_segments=1)\nparams = [\n    {\n        \"n_segments\": [1],\n        \"degree\": [0, 1, 2],\n    },\n    {\n        \"n_segments\": [2],\n        \"degree\": [[0, 0], [0, 1], [1, 0], [1, 1]],\n    },\n    {\n        \"n_segments\": [3],\n        \"degree\": [\n            [0, 0, 0],\n            [0, 0, 1],\n            [0, 1, 0],\n            [0, 1, 1],\n            [1, 0, 0],\n            [1, 0, 1],\n            [1, 1, 0],\n            [1, 1, 1],\n        ],\n    },\n]\ncv = GridSearchCV(\n    m,\n    param_grid=params,\n    cv=5,\n    n_jobs=-1,\n    scoring=\"neg_root_mean_squared_error\",\n    verbose=2,\n)\ncv.fit(x, y)\n</code></pre> <pre>\n<code>Fitting 5 folds for each of 15 candidates, totalling 75 fits\n</code>\n</pre> <pre>GridSearchCV(cv=5, estimator=AutoPiecewiseRegression(n_segments=1), n_jobs=-1,\n             param_grid=[{'degree': [0, 1, 2], 'n_segments': [1]},\n                         {'degree': [[0, 0], [0, 1], [1, 0], [1, 1]],\n                          'n_segments': [2]},\n                         {'degree': [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1],\n                                     [1, 0, 0], [1, 0, 1], [1, 1, 0],\n                                     [1, 1, 1]],\n                          'n_segments': [3]}],\n             scoring='neg_root_mean_squared_error', verbose=2)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org. <p>GridSearchCV<pre>GridSearchCV(cv=5, estimator=AutoPiecewiseRegression(n_segments=1), n_jobs=-1,\n             param_grid=[{\u2018degree\u2019: [0, 1, 2], \u2018n_segments\u2019: [1]},\n                         {\u2018degree\u2019: [[0, 0], [0, 1], [1, 0], [1, 1]],\n                          \u2018n_segments\u2019: [2]},\n                         {\u2018degree\u2019: [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1],\n                                     [1, 0, 0], [1, 0, 1], [1, 1, 0],\n                                     [1, 1, 1]],\n                          \u2018n_segments\u2019: [3]}],\n             scoring=\u2019neg_root_mean_squared_error\u2019, verbose=2)</pre> <p>estimator: AutoPiecewiseRegression<pre>AutoPiecewiseRegression(n_segments=1)</pre> <p></p> AutoPiecewiseRegression<pre>AutoPiecewiseRegression(n_segments=1)</pre> <p> </p> <pre><code>results = cv.cv_results_\n</code></pre> <pre><code>for i in range(4):\n    for candidate in np.flatnonzero(results[\"rank_test_score\"] == i):\n        print(\"Model {0}\".format(i))\n        print(\n            \"Mean RMSE: {0:.3f} (std: {1:.3f})\".format(\n                -1.0 * results[\"mean_test_score\"][candidate],\n                results[\"std_test_score\"][candidate],\n            )\n        )\n        print(\"Parameters: {0}\".format(results[\"params\"][candidate]))\n        print(\"\")\n</code></pre> <pre>\n<code>Model 1\nMean RMSE: 3.027 (std: 1.140)\nParameters: {'degree': [1, 0, 1], 'n_segments': 3}\n\nModel 2\nMean RMSE: 3.027 (std: 1.140)\nParameters: {'degree': [1, 1, 1], 'n_segments': 3}\n\nModel 3\nMean RMSE: 3.170 (std: 0.980)\nParameters: {'degree': [1, 1], 'n_segments': 2}\n\n</code>\n</pre> <pre><code>m_best = cv.best_estimator_\n</code></pre> <pre><code>xx = np.linspace(x.min(), x.max(), 1000)\nplt.plot(x, y, \".\")\nplt.plot(xx, m_best.predict(xx), \"-\")\nplt.show()\n</code></pre> <pre><code>m_best.breakpoints_\n</code></pre> <pre>\n<code>array([2.39868656e-03, 5.19420839e+01, 7.22632234e+01, 9.99766492e+01])</code>\n</pre> <pre><code>rmse = mean_squared_error(y, m_best.predict(x), squared=False)\nprint(\"RMSE:\", rmse)\nprint(\"CVRMSE: {:.2%}\".format(rmse / y.mean()))\n</code></pre> <pre>\n<code>RMSE: 2.882658390762755\nCVRMSE: 20.46%\n</code>\n</pre> <pre><code>m6 = pw.AutoPiecewiseRegression(n_segments=3, degree=1, continuity=None)\nm6.fit(x, y)\n</code></pre> <pre>AutoPiecewiseRegression(continuity=None, degree=[1, 1, 1], n_segments=3)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org. <p>AutoPiecewiseRegression<pre>AutoPiecewiseRegression(continuity=None, degree=[1, 1, 1], n_segments=3)</pre> <p> </p> <pre><code>plt.plot(x, y, \".\")\nplt.plot(xx, m6.predict(xx), \"-\")\nplt.show()\n</code></pre> <pre><code>rmse = mean_squared_error(y, m6.predict(x), squared=False)\nprint(\"RMSE:\", rmse)\nprint(\"CVRMSE: {:.2%}\".format(rmse / y.mean()))\n</code></pre> <pre>\n<code>RMSE: 2.8786752149931076\nCVRMSE: 20.43%\n</code>\n</pre> <pre><code>m7 = pw.AutoPiecewiseRegression(n_segments=3, degree=[1, 0, 1])\nm7.fit(x, y, weights=1 / sigma)\n</code></pre> <pre>AutoPiecewiseRegression(degree=[1, 0, 1], n_segments=3)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org. <p>AutoPiecewiseRegression<pre>AutoPiecewiseRegression(degree=[1, 0, 1], n_segments=3)</pre> <p> </p> <pre><code>plt.plot(x, y, \".\")\nplt.plot(xx, m7.predict(xx), \"-\")\nplt.show()\n</code></pre> <pre><code>m7.breakpoints_\n</code></pre> <pre>\n<code>array([2.39868656e-03, 5.19644765e+01, 7.21748633e+01, 9.99766492e+01])</code>\n</pre> <pre><code>rmse = mean_squared_error(y, m7.predict(x), squared=False)\nprint(\"RMSE:\", rmse)\nprint(\"CVRMSE: {:.2%}\".format(rmse / y.mean()))\n</code></pre> <pre>\n<code>RMSE: 2.882677596518861\nCVRMSE: 20.46%\n</code>\n</pre>"},{"location":"quickstart/#piecewise-regression-with-fixed-breakpoints","title":"Piecewise regression with fixed breakpoints","text":"<p>There are two primary arguments to the <code>PiecewiseLinearRegression</code> constructor: the breakpoint locations and the degree(s) of the fitted polynomial(s). Using the defaults results in a model that is identical to if you had used ordinary linear regression:</p>"},{"location":"quickstart/#piecewise-regression-with-unknown-breakpoints","title":"Piecewise regression with unknown breakpoints","text":"<p>To use <code>AutoPiecewiseRegression</code>, specify the number of line segments rather than the locations of the breakpoints. You can specify the degrees in the same way as with <code>PiecewiseLinearRegression</code>.</p>"},{"location":"quickstart/#advanced-use","title":"Advanced Use","text":"<p>Because <code>pwlreg</code> is compatible with scikit-learn, it can be used in the latter\u2019s pipelines, transformations, and cross-validation techniques. Suppose we weren\u2019t sure which kind of change-point model to use for a certain dataset, and we wanted a data-driven approach to selecting the best-performing one.</p> <p>We\u2019ll first simulate a larger realistic-ish dataset.</p>"},{"location":"quickstart/#cross-validation","title":"Cross Validation","text":""},{"location":"quickstart/#continuity","title":"Continuity","text":"<p>If you don\u2019t want to enforce continuity of the line segments for some reason, just pass <code>continuity=None</code> to either estimator.</p>"},{"location":"quickstart/#sample-weights","title":"Sample weights","text":"<p>Weighted regression is supported by passing <code>weights</code> to the <code>.fit()</code> method. This makes little difference in this contrived example, but it could help the fit in areas of the data that are more important than others.</p>"},{"location":"quickstart/#future-enhancements","title":"Future enhancements","text":"<ul> <li>Standard errors and p-values for coefficients</li> <li>C2 continuity (continuity of the line segments and their derivatives)</li> </ul>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#pwlreg.pwlreg","title":"pwlreg","text":"<p>PWLReg: A flexible implementation of piecewise least squares regression.</p>"},{"location":"reference/#pwlreg.pwlreg.AutoPiecewiseRegression","title":"AutoPiecewiseRegression","text":"<pre><code>AutoPiecewiseRegression(\n    n_segments,\n    *,\n    degree=1,\n    continuity=\"c0\",\n    solver=\"auto\",\n    random_state=None\n)\n</code></pre> <p>             Bases: <code>BaseEstimator</code>, <code>_BasePiecewiseRegressor</code></p> <p>Piecewise linear regression with unknown breakpoint locations.</p> <p>Parameters:</p> Name Type Description Default <code>n_segments</code> <code>int</code> <p>The number of line segments to fit.</p> required <code>degree</code> <code>int | list[int]</code> <p>The polynomial degree(s) of the line segments. If it is a single integer, all segments will have the same degree. If it is specified as a list, its length must be equal to <code>n_segments</code>. A degree of 0 will fit a constant (flat) line, 1 will fit a straight line, and 2 will fit a quadratic curve.</p> <code>1</code> <code>continuity</code> <code>str</code> <p>The degree of continuity for the line segments at the breakpoints. The default of <code>c0</code> means the segments will connect, but not necessarily smoothly (i.e. their derivatives may not be equal). <code>None</code> means the line segments can be fit completely separately from one another.</p> <code>'c0'</code> <code>solver</code> <code>str</code> <p>The optimization routine to use in finding the breakpoints.</p> <code>'auto'</code> <code>random_state</code> <code>Any</code> <p>Used in stochastic solvers for reproducibility.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>breakpoints_</code> <p>Optimal breakpoint locations. The first and last elements will always be the min and max of the input data.</p> <code>coef_</code> <p>Vector coefficients that minimize the sum of squared errors.</p> <code>ssr_</code> <p>Sum of squared errors resulting from the fit.</p> <code>n_params_</code> <p>Number of estimated parameters.</p> <code>n_iter</code> <p>Number of iterations the solver needed to converge.</p> <p>Initialize the auto regression object.</p> Source code in <code>src/pwlreg/pwlreg.py</code> <pre><code>def __init__(\n    self,\n    n_segments: int,\n    *,\n    degree: int | list[int] = 1,\n    continuity: str = \"c0\",\n    solver: str = \"auto\",\n    random_state: Any = None\n) -&gt; None:\n    \"\"\"Initialize the auto regression object.\"\"\"\n    self.n_segments = n_segments\n    self.solver = solver\n    self.random_state = random_state\n    super().__init__(degree, continuity)\n</code></pre>"},{"location":"reference/#pwlreg.pwlreg.AutoPiecewiseRegression.fit","title":"fit","text":"<pre><code>fit(X, y, weights=None)\n</code></pre> <p>Fit piecewise regression model, finding optimal breakpoints.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ArrayLike</code> <p>Input data</p> required <code>y</code> <code>ArrayLike</code> <p>Target values</p> required <code>weights</code> <code>ArrayLike</code> <p>Individual weights for each sample. If given a float, every sample will have the same weight.</p> <code>None</code> <p>Returns:</p> Type Description <code>AutoPiecewiseRegression</code> <p>Fitted estimator.</p> Source code in <code>src/pwlreg/pwlreg.py</code> <pre><code>def fit(\n    self, X: npt.ArrayLike, y: npt.ArrayLike, weights: npt.ArrayLike = None\n) -&gt; \"AutoPiecewiseRegression\":\n    \"\"\"Fit piecewise regression model, finding optimal breakpoints.\n\n    Args:\n        X: Input data\n        y: Target values\n        weights: Individual weights for each sample. If given a float, every\n            sample will have the same weight.\n\n    Returns:\n        Fitted estimator.\n    \"\"\"\n    random_state_ = check_random_state(self.random_state)\n    X, y = check_X_y(X, y, accept_sparse=True, ensure_2d=False, y_numeric=True)\n    weights = _check_sample_weight(weights, X, dtype=X.dtype)\n\n    if self.n_segments == 1:\n        self.breakpoints_ = np.array([np.min(X), np.max(X)])\n        return self.fit_with_breaks(X, y, self.breakpoints_, weights)\n\n    self.breakpoints_, self.n_iter = _auto_piecewise_regression(\n        X,\n        y,\n        self.n_segments,\n        self.degree,\n        self.continuity,\n        weights,\n        solver=self.solver,\n        random_state=random_state_,\n        return_n_iter=True,\n    )\n\n    return self.fit_with_breaks(X, y, self.breakpoints_)\n</code></pre>"},{"location":"reference/#pwlreg.pwlreg.AutoPiecewiseRegression.predict","title":"predict","text":"<pre><code>predict(X)\n</code></pre> <p>Predict using the fitted piecewise regression model with optimal breakpoints.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ArrayLike</code> <p>Input data</p> required <p>Returns:</p> Type Description <code>ArrayLike</code> <p>Predicted values</p> Source code in <code>src/pwlreg/pwlreg.py</code> <pre><code>def predict(self, X: npt.ArrayLike) -&gt; npt.ArrayLike:\n    \"\"\"Predict using the fitted piecewise regression model with optimal breakpoints.\n\n    Args:\n        X: Input data\n\n    Returns:\n        Predicted values\n    \"\"\"\n    return self._decision_function(X, self.breakpoints_)\n</code></pre>"},{"location":"reference/#pwlreg.pwlreg.PiecewiseLinearRegression","title":"PiecewiseLinearRegression","text":"<pre><code>PiecewiseLinearRegression(\n    *, breakpoints=None, degree=1, continuity=\"c0\"\n)\n</code></pre> <p>             Bases: <code>BaseEstimator</code>, <code>_BasePiecewiseRegressor</code></p> <p>Piecewise linear regression with known breakpoint locations.</p> <p>Parameters:</p> Name Type Description Default <code>breakpoints</code> <code>ArrayLike</code> <p>Array of breakpoint locations. Must include the minimum and maximum points of your input data. If <code>None</code>, it is assumed to be the min and max of the input data with no points in between. This will result in a single line segment being fit to the data.</p> <code>None</code> <code>degree</code> <code>int | list[int]</code> <p>The polynomial degree(s) of the line segments. If it is a single integer, all segments will have the same degree. If it is specified as a list, its length must be one less than the number of breakpoints. A degree of 0 will fit a constant (flat) line, 1 will fit a straight line, and 2 will fit a quadratic curve.</p> <code>1</code> <code>continuity</code> <code>str</code> <p>The degree of continuity for the line segments at the breakpoints. The default of <code>c0</code> means the segments will connect, but not necessarily smoothly (i.e. their derivatives may not be equal). <code>None</code> means the line segments can be fit completely separately from one another.</p> <code>'c0'</code> <p>Attributes:</p> Name Type Description <code>coef_</code> <p>Vector coefficients that minimize the sum of squared errors.</p> <code>ssr_</code> <p>Sum of squared errors resulting from the fit.</p> <code>n_params_</code> <p>Number of estimated parameters.</p> <p>Initialize the regression object.</p> Source code in <code>src/pwlreg/pwlreg.py</code> <pre><code>def __init__(\n    self,\n    *,\n    breakpoints: npt.ArrayLike = None,\n    degree: int | list[int] = 1,\n    continuity: str = \"c0\"\n) -&gt; None:\n    \"\"\"Initialize the regression object.\"\"\"\n    self.breakpoints = breakpoints\n    super().__init__(degree, continuity)\n</code></pre>"},{"location":"reference/#pwlreg.pwlreg.PiecewiseLinearRegression.fit","title":"fit","text":"<pre><code>fit(X, y, *, weights=None)\n</code></pre> <p>Fit piecewise regression model.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ArrayLike</code> <p>Input data</p> required <code>y</code> <code>ArrayLike</code> <p>Target values</p> required <code>weights</code> <code>ArrayLike</code> <p>Individual weights for each sample. If given a float, every sample will have the same weight.</p> <code>None</code> <p>Returns:</p> Type Description <code>PiecewiseLinearRegression</code> <p>Fitted estimator.</p> Source code in <code>src/pwlreg/pwlreg.py</code> <pre><code>def fit(\n    self, X: npt.ArrayLike, y: npt.ArrayLike, *, weights: npt.ArrayLike = None\n) -&gt; \"PiecewiseLinearRegression\":\n    \"\"\"Fit piecewise regression model.\n\n    Args:\n        X: Input data\n        y: Target values\n        weights: Individual weights for each sample. If given a float, every\n            sample will have the same weight.\n\n    Returns:\n        Fitted estimator.\n    \"\"\"\n    X, y = check_X_y(X, y, accept_sparse=True, ensure_2d=False, y_numeric=True)\n    weights = _check_sample_weight(weights, X, dtype=X.dtype)\n\n    if self.breakpoints is None:\n        self.breakpoints = np.array([np.min(X), np.max(X)])\n\n    self.fit_with_breaks(X, y, self.breakpoints, weights)\n    return self\n</code></pre>"},{"location":"reference/#pwlreg.pwlreg.PiecewiseLinearRegression.predict","title":"predict","text":"<pre><code>predict(X)\n</code></pre> <p>Predict using the fitted piecewise regression model.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ArrayLike</code> <p>Input data</p> required <p>Returns:</p> Type Description <code>ArrayLike</code> <p>Predicted values</p> Source code in <code>src/pwlreg/pwlreg.py</code> <pre><code>def predict(self, X: npt.ArrayLike) -&gt; npt.ArrayLike:\n    \"\"\"Predict using the fitted piecewise regression model.\n\n    Args:\n        X: Input data\n\n    Returns:\n        Predicted values\n    \"\"\"\n    return self._decision_function(X, self.breakpoints)\n</code></pre>"}]}